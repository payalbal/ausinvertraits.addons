---
title: "AFD checklist"
author: "Payal Bal, Fonti Kar"
date: "2022-08-30"
output: html_document
editor_options: 
chunk_output_type: console
---
  
  ```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r }
#install.packages("pacman")
pacman::p_load(dplyr, janitor, galah, stringr, tidyverse, arrow, stringr, data.table, CoordinateCleaner)

## Functions 
source("scripts/remove_improper_names_v2.R") # Version Fonti created
```

### Australian Faunal Directory taxonomy

```{r}
afd_species <- read_csv("databases/afd_splist_full.csv")
all_species <- afd_species$VALID_NAME 
```

### Remove improper names 

```{r}
species_record <- remove_improper_names_v2(all_species,
                                           allow.higher.taxa = FALSE,
                                           allow.subspecies = TRUE)

# Double checking if there are any NAs in updated list
is.na(species_record$updated_list) |> table() 

# Filter records based on updated list
afd_species |> 
  dplyr::filter(VALID_NAME %in% species_record$updated_list) -> afd_species
```

### Remove invasive species 

##The original workflow uses the GRIIS list downloaded from the ALA website. The code below uses a more up-to-date list from the ALA which is not currently on the website.
##This section is currently under development by Fonti with consultation with person who manages GRIIS list at ALA (Donald?)
```{r}
# Read in the various txt files that make up the GRIIS list
distribution <- fread("dwca-griis-australia-v1.6/distribution.txt")
species <- fread("dwca-griis-australia-v1.6/speciesprofile.txt")
taxa <- fread("dwca-griis-australia-v1.6/taxon-edited.txt", fill = TRUE)

# Create the GRIIS list
griis_list <- taxa |>  
  full_join(distribution, by = "id") |>  
  full_join(species, by = "id")

# Use galah::search_taxa() to get tidy names and filter by noIssues
griis_ala_raw <- data.frame(search_taxa(griis_list$scientificName))

# Pre-process the GRIIS list and filter by noIssues and no missing values in species
griis_ala_tidy <- griis_ala_raw |>  
  filter(issues == "noIssue",
         !is.na(species)) |>  
  dplyr::select(search_term, taxon_concept_id, scientific_name, scientific_name_authorship)

# Cross matching AFD to updated GRIIS list and reporting
message(cat("number of AFD species listed in GRIIS: "),
        length(which(afd_species$VALID_NAME %in% griis_ala_tidy$scientific_name)))

message("AFD species in GRIIS - Global Register of Introduced and Invasive Species - Australia: ")
afd_species$VALID_NAME[which(afd_species$VALID_NAME %in% griis_ala_tidy$Supplied.Name)]

message("Removing AFD species in GRIIS ...")
afd_species <- afd_species[which(! afd_species$VALID_NAME %in% griis_ala_tidy$Supplied.Name),]

# Excluding from AFD list
message("Removing the following AFD species with GRIIS ...")
updated_griis_afd <- afd_species$VALID_NAME[which(afd_species$VALID_NAME %in% griis_ala_tidy$scientific_name)]

message("Updated AFD with species excluded ...")
afd_species <- afd_species[! afd_species$VALID_NAME %in% griis_ala_tidy$scientific_name, ]
```

#### Old workflow for removing invasive species
## we will work with both updated GRIIS list (above) and old version downloaded from ALA website (below) for now

```{r}
  griis_species <- read.csv("databases/GRIIS_Global_Register_of_Introduced_and_Invasive_Species_Australia.csv")
  
  message(cat("number of AFD species listed in GRIIS: "),
          length(which(afd_species$VALID_NAME %in% griis_species$Supplied.Name)))
  
  message("AFD species in GRIIS - Global Register of Introduced and Invasive Species - Australia: ")
  old_griis_afd <- afd_species$VALID_NAME[which(afd_species$VALID_NAME %in% griis_species$Supplied.Name)]
  
  message("Removing the following AFD species with GRIIS ...")
  afd_species <- afd_species[! afd_species$VALID_NAME %in% griis_species$Supplied.Name,]
  ```

  ## Remove Marine species
  
  ### Using World Register of Marine species (WoRMs) 
  ## old workflow- will remove this (lines 104-198) from script
  ##WoRMs used as a first sweep to remove marine species
  Passing taxonomic names to: `worrms::wm_records_names()` will return a dataframe of marine species! There is a limit of about 100 species in each API query so it can take a while! I have done this already and saved the output as a .csv. 
  
  For more info: https://docs.ropensci.org/worrms/
    
    You can request a download of WoRMS here: https://www.marinespecies.org/usersrequest.php. which they update once a month
  Issue is there is n valid name just scientific name
  We would need to make decisions about taxonomic status and do a pre-process ourselves. A very general clean gives me about  6,108 species - see workflow/worrms.rmd
  
  - PB to export species list of semi-marine, marine/brackish to experts to cross verify this list
  
  ##WoRMS list bulk downloaded as two .txt files
  ##use code below to compile worms list together
 
  species <- fread(file.path(getwd(),"WoRMS_download_2022-10-01", "speciesprofile.txt"), quote = "")
  taxa <- fread(file.path(getwd(), "WoRMS_download_2022-10-01", "taxon.txt"), quote = "")
  
  # create a GRIIS list
  worms_list <- taxa |>  
    full_join(species, by = "taxonID")
  
  worms_list
  names(worms_list)
  
  ## Number of strictly marine species
  worms_list %>%
    filter(!specificEpithet == "",
           taxonomicStatus == "accepted",
           isMarine == 1,
           isTerrestrial == 0, isFreshwater == 0, isExtinct == 0) -> accepted_marine_worms  # 57,414 species
  
  
  afd_species |> filter(VALID_NAME %in% accepted_marine_worms$scientificName) # 6,074 matched
  
  ##exclude these marine species from afd list
  afd_species |> 
    filter(! VALID_NAME %in% accepted_marine_worms$scientificName) -> afd_species
  
  ##Remove Marine species using World Register of Marine species (WoRMs) .csv file (downloaded by Fonti using API and put together into csv format)
  ##Under development by Fonti 
  worms <- read_csv("databases/worrms_marine_splist.csv")
  names(worms)
  
  ## Any missing values in scientificname, valid_name?
  is.na(worms$scientificname) |> table()
  is.na(worms$valid_name) |> table()
  
  ## Do valid name match scientific name?
  (worms$valid_name == worms$scientificname) |> janitor::tabyl()
  
  ## WoRMS has these really helpful identifiers of habitat occupancy of each taxa
  ## IA wants to exclude marine species exclusively so TRUE for isMarine and NA/FALSE for the others
  worms %>% select(starts_with("is")) %>% colSums(., na.rm = TRUE)
  
  ## Number of strictly marine species
  worms %>%
    filter(isMarine == 1,
           isBrackish == 0, isTerrestrial == 0, isFreshwater == 0, isExtinct == 0) -> marine_worms # 6768 species
  
  ## Which names don't match? I suggest cross-checking with AFD using both scientificname and valid_name for these marine species
  marine_worms |> 
    filter(! valid_name == scientificname) |> 
    select(valid_name, scientificname) 
  
  ## First which species are excluded because they are marine 
  afd_species |> 
    filter(VALID_NAME %in% marine_worms$valid_name) |>
    select(VALID_NAME) ->  excluded_mar_species
  
  nrow(excluded_mar_species) # 26
  
  ## Exclude these species 
  afd_species |> 
    filter(! VALID_NAME %in% marine_worms$valid_name) -> nomarine_nogriis_afd_species
  
  # Checking
  nrow(nomarine_nogriis_afd_species) + nrow(excluded_mar_species) == nrow(afd_species)
  
  # Further exclusion using scientificname
  ## Which species are excluded by scientificname
  nomarine_nogriis_afd_species |> 
    filter(VALID_NAME %in% marine_worms$scientificname) |> 
    select(VALID_NAME) -> excluded_mar_species_scientificname
  
  nrow(excluded_mar_species_scientificname) # 575
  
  ## Further exclude excluded_mar_species_scientificname
  nomarine_nogriis_afd_species |> 
    filter(! VALID_NAME %in% marine_worms$scientificname) -> nomarine_nogriis_afd_species_snm
  
  nrow(nomarine_nogriis_afd_species_snm) + nrow(excluded_mar_species) + nrow(excluded_mar_species_scientificname) == nrow(afd_species)
 
  afd_species <- nomarine_nogriis_afd_species_snm
  
  ###New WoRMs workflow by Fonti as of Jan 2023
  ```{r}
  # install.packages("worrms") https://docs.ropensci.org/worrms/index.html
  
  pacman::p_load(tidyverse, worrms, here, job)
  ```
  
  Read in AFD list
  
  ```{r}
  afd_taxonomy <- read_csv("output/afd_species_clean.csv"). ##do we just keep using the afd list from above with the improper names and invasive species removed rather than reading in a the clean version?
  afd_species <- unique(afd_taxonomy$VALID_NAME) 
  ```
  
  ## A small test
  
  ```{r}
  set.seed(8)
  
  x <- sample(afd_species, 50) 
  
  test_alltypes_ls <- wm_records_names(x)
  test_alltypes_df <- bind_rows(test_alltypes_ls)
  
  test_df |> select(scientificname, starts_with("is")) 
  
  x[which(x %in% marine_sp)] # Seems to work well! 
  
  ```
  
  ## Lets expand it
  
  ```{r}
  # If I do full list, it runs out of memory, reducing list to 500, 200, 100 seems to work
  # afd_species_ls <- wm_records_names(afd_species) |> bind_rows() 
  
  afd_species_ls <- wm_records_names(afd_species[1:100]) |> bind_rows()
  ```
  
  ## Workflow to exclude marine species from AFD checklist
  
  ```{r}
  afd_species_ls |> pull(scientificname) -> marine_afd
  
  ## Excluding the marine species in VALID_NAME
  afd_taxonomy |> filter(! VALID_NAME %in% marine_afd) -> afd_taxonomy_nomarine
  ```
  
  ## Code for for loop to query their API - slow, 1hr 
  
  ```{r}
  # The AFD species we want to check with WoRMS
  afd_species <- unique(afd_taxonomy$VALID_NAME) 
  
  # Split the species list to chunks of 120 species
  afd_species_chunks <- split(afd_species, ceiling(seq_along(afd_species)/120))
  
  
  
  # Create empty list to populate
  worms_ls <- list()
  
  for (i in 1:length(afd_species_chunks[1:5])) {
    
    message(cat("Working on", names(afd_species_chunks)[i], "/", length(afd_species_chunks)))
    
    try(worrms::wm_records_names(afd_species_chunks[[i]]) -> tmp)
    
    tmp |> bind_rows() -> worms_ls[[i]]
    
  }
  
  # Collapse the list down
  worms_afd_query_results <- worms_ls %>% bind_rows()
  
  # Save as a .csv
  write_csv(worms_afd_query_results, "output/worms_afd_query_results.csv")
  ```
  
  ## Make the loop into a background RStudio job
  
  This took 1hr and 6 mins
  
  ```{r}
  ##couldn't get this to work (but have never used it before so didnt know if I was doing something wrong!)
  job({
    # Create empty list to populate
    worms_ls <- list()
    
    for (i in 1:length(afd_species_chunks)) {
      
      message(cat("Working on", names(afd_species_chunks)[i], "/", length(afd_species_chunks)))
      
      try(worrms::wm_records_names(afd_species_chunks[[i]]) -> tmp)
      
      tmp |> bind_rows() -> worms_ls[[i]]
      
    }
    
    # Collapse the list down
    worms_afd_query_results <- worms_ls %>% bind_rows()
    
    # Save as a .csv
    write_csv(worms_afd_query_results, "output/worms_afd_query_results.csv")
  })
  ```
  
  ### Exclude marine species found by WoRMs by VALID_NAME with API query data
  
  Options to exclude by scientificname or valid name
  
  ```{r}
  worms_afd_query_results <- read_csv("output/worms_afd_query_results.csv")
  
  # Clean the list
  worms_afd_query_results %>% filter(duplicated(AphiaID)) %>% nrow()
  worms_afd_query_results %>% filter(!duplicated(AphiaID)) -> worms_afd_query_results
  
  worms_afd_query_results$scientificname |> length()
  worms_afd_query_results$valid_name |> length()
  
  (worms_afd_query_results$scientificname == worms_afd_query_results$valid_name) |> janitor::tabyl()
  
  # Exclude the matches
  afd_taxonomy |> filter(! VALID_NAME %in% worms_afd_query_results$scientificname) # 91,577
  afd_taxonomy |> filter(! VALID_NAME %in% worms_afd_query_results$valid_name) -> afd_taxonomy # 94,147:
  
  ## The excluded taxa
  afd_taxonomy |> 
    filter(VALID_NAME %in% worms_afd_query_results$scientificname) %>% 
    pull(VALID_NAME)# 21,019 species excluded
  
  
  afd_taxonomy |> 
    filter(VALID_NAME %in% worms_afd_query_results$valid_name) %>% 
    pull(VALID_NAME) # 18,448  species excluded
  ```
 
  ##From old WoRMs method...to be removed?
   ### Reporting 
  message(paste("Found ", nrow(excluded_mar_species), " marine species by validname in WoRMS"))
  message(paste("After exclusion by validname, a further", nrow(excluded_mar_species_scientificname), "marine species were found by scientificname in WoRMS"))
  message(paste("The total number of AFD species remaining following complete exclusion is ", nrow(nomarine_nogriis_afd_species_snm)))
  
  
  
  ####remove marine species using CAAB
  ## CAAB used for a finer sweep for local marine species-still under development?
  ## code from original splist_AFD_script
  ##to be removed from script?
  
  Using CAAB data: https://www.cmar.csiro.au/data/caab/
    
    ```{r}
  # Read in data
  caab_species <- fread("databases/caab_dump_latest.csv")
  
  # Create scientific name
  caab_species |> mutate(scientific_name = ifelse(! is.na(SPECIES),
                                                  paste0(GENUS," ", SPECIES),
                                                  NA)) -> caab_species
  # Overlap 
  intersect(all_species, caab_species) # ZERO
  
  afd_species |> filter(VALID_NAME %in% caab_species) # ZER0 
  ```
  
  
  ## Identifying duplicates 
  
  This section identify duplicates at the level of: 
    - row
  - `VALID_NAME`
  - `COMPLETE_NAME`
  
  The number of species > the number of _unique_ species implies that there are duplicates.
  JM: use `COMPLETE_NAME` for finding duplicates
 
   
  
  ```{r}
  ## List duplicates comparing all columns
  afd_species[duplicated(afd_species),] 
  
  ## Look for duplicates in specific columns
  sum(is.na(afd_species$VALID_NAME)) # Count number of NA in VALID_NAME
  length(afd_species$VALID_NAME) # Total species
  length(unique(afd_species$VALID_NAME)) # Total unique VALID_NAME
  length(unique(afd_species$COMPLETE_NAME)) # Total unique COMPLETE_NAME
  ```
  
  ## Duplicates in COMPLETE_NAME (excluding first appearance)
  
  ```{r}
  message(cat("Number of duplicated COMPLETE_NAME (excluding first appearance): "), 
          length(afd_species$COMPLETE_NAME[duplicated(afd_species$COMPLETE_NAME)]))
  message("duplicated COMPLETE_NAME: ")
  afd_species$COMPLETE_NAME[duplicated(afd_species$COMPLETE_NAME)]
  ```
  
  ## Duplicates in COMPLETE_NAME (*including* first appearance)
  
  ```{r}
  
  afd_species$COMPLETE_NAME[duplicated(afd_species$COMPLETE_NAME) | duplicated(afd_species$COMPLETE_NAME, fromLast=TRUE)] -> dup_temp
  
  message(cat("#duplicates in COMPLETE_NAME (including first appearance) : ", length(dup_temp)))
  message("duplicated COMPLETE_NAME: ")
  dup_temp
  
  #remove duplicates from afd list
  
  
  # readr::write_csv(temp, "output/afd_completename_repeats.csv") ##this didn't work when written like this so have changed to the code below
  write.csv(dup_temp, "output/afd_completename_repeats.csv")
  
  #write clean afd species list to .csv file
  write.csv(afd_species, "output/afd_species_clean.csv")
  

## Various checks and tallies

Checks or tallies of species according to the number of words and particular formatting patterns in `VALID_NAME`

Note: '\' is an escape operator for various special characters

```{r}
## Counts for number of words
str_count(afd_species$VALID_NAME, pattern = "\\S+") |> janitor::tabyl()

## Counts for special characters in species names
stringr::str_count(afd_species$VALID_NAME, pattern = regex("\\\"")) |> sum() # Counting occurrences for \"
stringr::str_count(afd_species$VALID_NAME, pattern = regex("'")) |> sum() # Counting occurrences for '
stringr::str_count(afd_species$VALID_NAME, pattern = regex("\\(")) |> sum() 
stringr::str_count(afd_species$VALID_NAME, pattern = regex("\\[")) |> sum() 
```



