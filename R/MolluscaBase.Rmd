---
title: "MolluscaBase"
author: "Fonti Kar"
date: "2023-06-19"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

pacman::p_load(tidyverse, arrow, janitor, worrms, job, readxl)
```

```{r}
afd_may <- read_csv_arrow("data/afd_May2023_clean.csv")
```

### Filter out Molluscs

Prepare for MatchTool in WoRMs/MolluscaBase

Check First Row Contains Column Names
Row delimited LF
Columns delimited ;

```{r}
matchtool <- afd_may |> filter(
  PHYLUM == "MOLLUSCA"
) |> 
  select(FAMILY, GENUS, SPECIES, COMPLETE_NAME)

# Save Mollusca
# write_csv(matchtool, "outputs/AFD_May_Molluscs.csv") 

# Split authority
match_clean <- matchtool |> 
  mutate(split = map(.x = COMPLETE_NAME,
                         ~str_split(.x, pattern = ", ")),
         scientific_name = map(split, 
                         ~pluck(.x, 1, 1)),
         authority = map(split, 
                         ~pluck(.x, 1, 2))) |> 
  select(-split) |> 
  unnest(cols = c("scientific_name","authority"))  |>  
  rename(Family = FAMILY, 
         Genus = GENUS, 
         species = SPECIES, 
         ) 


# Split so it has 1500 rows
chunk <- 1499
n <- nrow(match_clean)
r  <- rep(1:ceiling(n/chunk),each=chunk)[1:n]
d <- split(match_clean,r)

names(d) <- paste0("matchtool_", names(d))

# Save each chunk as .csv
# walk2(.x = d, .y = names(d), 
#      ~write_excel_csv2(.x, file = paste0("outputs/", .y, ".csv")))

```

### Read in output from matchtool

```{r}
matched_output <- read_delim("data/matchtool_1_matched.txt", delim = ";")
matched_output_2 <- read_delim("data/matchtool_2_matched.txt", delim = ";")

write_csv(matched_output, "outputs/matchtool_1_matched.csv") 
write_csv(matched_output_2, "outputs/matchtool_2_matched.csv") 
```

### Try use WoRMs API

Fuzzy match = TRUE

```{r}
species_chunks <- split(match_clean$scientific_name, ceiling(seq_along(match_clean$scientific_name)/120))

# Testing on single case
species_chunks |> pluck(2,16) |> wm_records_name() |> mutate(search_term = species_chunks |> pluck(2,16))

# Testing for 120 species
test <- map(species_chunks |> pluck(2),
    possibly(~wm_records_name(.x) |> mutate(search_term = .x))) |> 
  discard(.p = ~is.null(.x)) 
  
# Testing entire species list
job({
output <- map(match_clean$scientific_name,
    possibly(~wm_records_name(.x) |> 
               mutate(search_term = .x))) |> 
  discard(.p = ~is.null(.x)) 
})


output_df <- output |> list_rbind()

# write_csv(output_df, "outputs/API_WoRMS_matched.csv")
output_df <- read_csv("outputs/API_WoRMS_matched.csv")
```

```{r}
output_df |> 
  pull(match_type) |> 
  tabyl()

output_df |> 
  mutate(match = search_term == scientificname) |> 
  select(AphiaID:url,match, search_term, scientificname:modified) |>
  filter(match == FALSE)
```

Fuzzy match is not true

```{r}
species_chunks <- split(match_clean$scientific_name, ceiling(seq_along(match_clean$scientific_name)/120))

# Testing on single case
species_chunks |> pluck(2,16) |> wm_records_name(fuzzy = FALSE) |> mutate(search_term = species_chunks |> pluck(2,16))

# Testing for 120 species
test <- map(species_chunks |> pluck(2),
    possibly(~wm_records_name(.x, fuzzy = FALSE) |> mutate(search_term = .x))) |> 
  discard(.p = ~is.null(.x)) 
  
# Testing entire species list
job({
output_nofuzz <- map(match_clean$scientific_name,
    possibly(~wm_records_name(.x, fuzzy = FALSE) |> 
               mutate(search_term = .x))) |> 
  discard(.p = ~is.null(.x)) 
})


output_df <- output |> list_rbind()

# write_csv(output_df, "outputs/API_WoRMS_matched.csv")
output_df <- read_csv("outputs/API_WoRMS_matched.csv")
```

Try wm_records_taxamatch()

There are several types of matches:
exact all characters match exactly
exact_subgenus an exact match, but including the subgenus
phonetic sounds similar as, despite minor differences in spelling (soundex algorithm)
near_1 perfect match, except for one character. This is a quite reliable match
near_2 good match, except for two characters. This needs an extra check
near_3 good match, except for three characters. This definitely needs an extra check
match_quarantine match with a name that is currently in quarantine. Any name that has been used in the literature should in principle not be quarantined. So best to contact the WoRMS DMT about this
match_deleted this is a match with a name that has been deleted and no alternative is available. Please contact the WoRMS DMT when you come across this.

```{r}
# Testing on single case
species_chunks |> pluck(2,16) |> wm_records_taxamatch(marine = FALSE) |> pluck(1) |> mutate(search_term = species_chunks |> pluck(2,16))

# Testing for 120 species
test <- map(species_chunks |> pluck(2),
    possibly(~wm_records_taxamatch(.x, marine = FALSE) |> pluck(1) |> mutate(search_term = .x))) |> 
  discard(.p = ~is.null(.x)) |> 
  list_rbind() 

# Job takes 2hrs and 40 mins to run  

job({
  output_df <- map(match_clean$scientific_name,
                   possibly(~wm_records_taxamatch(.x, marine = FALSE)  |>
                              pluck(1)  |>
                              mutate(search_term = .x) |>
                              discard(.p = ~is.null(.x))
                   )
  ) |> 
    list_rbind()
  
  saveRDS(output_df, "outputs/worrms_taxamatch")
})


worrms_taxamatch <- readRDS("outputs/worrms_taxamatch")

# Types of fuzzy match
worrms_taxamatch |> 
  pull(match_type) |> 
  tabyl()

# Which are the taxa that were not matched in WoRMS (i.e we are a name but WoRMS does not)
setdiff(match_clean$scientific_name, worrms_taxamatch$search_term) |> length()

# Which ones that are not exact matches - this maybe ones that we need to update OR we have a newer name or completely unrelated species
worrms_taxamatch |> 
  filter(! match_type == "exact") |> 
  select(search_term, ends_with("name"),  match_type, valid_authority) |> 
  arrange(match_type) |> 
  print(n = 100) |> 
  write_csv(paste0("outputs/AFD_WoRMS_taxamatch_notexactmatchtype", Sys.Date(), "_.csv"))
```

Read in data sent by Data Management team for all of Australia

```{r}
aus_worms <- readxl::read_xlsx("data/WoRMS_Mollusca_australia_20230621.xlsx")

names(aus_worms)

# Cross compare with taxamatch data
setdiff(unique(aus_worms$ScientificName), unique(worrms_taxamatch$scientificname)) |> length()
setdiff(unique(aus_worms$ScientificName), unique(match_clean$scientific_name)) |> length()

# Locality breakdown
aus_worms
```

## Use the distribution API to get the same data above

```{r}

```

